# Decpack - 整数/固定小数点データ専用圧縮エンコーダ/デコーダ

Decpackは整数及び固定小数点数値データの圧縮保存(エンコード)とその復元(デコード)処理を行うRubyモジュール(gem)です。

このモジュールは(データをgzipなどで圧縮保存する場合の下処理として)数値データから余分な情報を取り除き、必要最小限の情報にコンパクト化する事を目的としています。詳しくは「原理説明と簡単な例」で説明します。

## システム環境

本モジュールはRuby 1.9以上の環境で動作します(開発は2.0上で行いました)。次のバージョンでテストによる動作確認を行っています。

* 1.9.3-p448
* 2.0.0-p247

> デコード専用のJavaScript版もあります。詳細は後の「JavaScriptデコーダ」で説明します。

## インストール

配布ファイルはgemパッケージになっています。decpack-0.0.1.gemをダウンロードして次でインストールできます。新しいモジュールですから他モジュールとの依存性はありません。

    $ gem install decpack-0.0.1.gem
    Successfully installed decpack-0.0.1
    1 gem installed

> 現在はまだRubyGemsには登録していません(作者自身まだどれほど有効性があるのかよく分かっていません)。本ドキュメントの最後でgzipなど既存圧縮アルゴリズムと併用した場合の有効性検討を行っていますので興味のある方はご覧下さい。

不要な場合は次でアンインストールできます。

    $ gem uninstall decpack
    Successfully uninstalled decpack-0.0.1

# テスト

testディレクトリにユニットテスト一式のコードが付属しています。次のコマンドでテストを実行します。

    $ rake test

> JavaScriptデコーダのテストコードはなく、Webアプリケーションに組み込んだ状態での動作確認のみ行っています。

## 原理説明と簡単な例

### 整数データの圧縮保存

原理を説明するためまず簡単な実際のデータ例を示します。次の値は東京の2013年12月1日の一時間おきの湿度で、1%間隔で0から100までの値を取ります。このデータをどのように効率的に圧縮して保存できるかを考えます。

<http://www.data.jma.go.jp/obd/stats/etrn/view/hourly_s1.php?prec_no=44&block_no=47662&year=2013&month=12&day=1&view=>

    64,67,56,67,70,73,73,60,60,56,53,49,41,35,43,55,62,69,59,56,59,71,64,60

> ここでは説明用に短いデータを使いますが、実際はもっと大きなデータを想定しています。このDecpackはもともと日本国中の膨大な気象データを保存する目的で開発したものです。

まずこのデータはCSV形式になっています。CSVはXMLやJSONに比べれば効率のよいフォーマットで(その代わり複雑なデータ構造は表現できません)、上の例の場合は71byteに収まります。

次にPerlや(その仕様を継承した)Rubyにはバイナリエンコーディング文字列を入出力の対象としてpackでデータを文字列に変換し、unpackでデータを復元する機能があります。これを使えばバイト単位で最適のフォーマットを選択して変換することができます。

今回のケースは全て255以下の符号なし整数ですからフォーマット(テンプレート文字列)として8bit符号なし整数の`C`を使えば24byteに圧縮することができます。Rubyのコード例を示します。

    data = [
      64, 67, 56, 67, 70, 73, 73, 60, 60, 56, 53, 49,
      41, 35, 43, 55, 62, 69, 59, 56, 59, 71, 64, 60
    ]

    packed = data.pack 'C*'
    p packed.size       # => 24

    unpacked = packed.unpack 'C*'
    p unpacked          # => [64, 67, 56, ... , 60 ]

Decpackはこの考えをさらに進め、データ長を1ビット単位で設定できます。今回のケースでは値は0..100の整数ですから7bitの中に収めることができます。次は実際のコード例で、21byte(7 * 24 / 8)に圧縮するのを確認できます。

    require 'decpack'

    data = [
      64, 67, 56, 67, 70, 73, 73, 60, 60, 56, 53, 49,
      41, 35, 43, 55, 62, 69, 59, 56, 59, 71, 64, 60
    ]

    pack = Decpack.pack type: :binary
    data.each {|x| pack.B 7, x }
    packed = pack.output
    p packed.size       # => 21

    unpack = Decpack.unpack packed
    unpacked = 24.times.map { unpack.B 7 }
    p unpacked          # => [ 64, 67, 56, ... 60 ]

`pack B, 7, x`と`unpack.B 7`の`B`はエンコーダ及びデコーダオブジェクトのメソッド名で、第一引数の`7`がビット幅です。詳しくは後で説明します。

### 固定小数点データの圧縮保存

> ここで扱うデータの内部表現は浮動小数点数で、RubyではFloatクラスのオブジェクトです。ここでは小数部の桁数があらかじめ決められている場合を考え、以下では用語として「固定小数点」を用います。

次のデータは同じ日の気温をCSVで表現したものです(単位は℃)。今度は小数点付きの数で、桁数は小数点1桁、最小値は5.5、最大値は14.8です。CSVで表現した場合は109byteになります。

    7.8,7.1,8.2,6.4,5.9,5.5,5.9,8.4,8.2,10.8,12.3,13.0,14.6,14.8,14.8,13.6,12.1,10.5,12.5,12.4,12.0,9.8,11.4,10.7

これをpack/unpackで変換する場合は`f`を使えば1データあたり4バイトに変換し、計96バイトに収まります。しかしこれではCSVと大差ありません。

> `f`は機種依存エンディアンの単精度浮動小数点数に変換します(Perl/Ruby共通)。Rubyではこの他に`g`(リトルエンディアンの単精度)や`e`(ビッグエンディアンの単精度)を利用できます(perldocを調べましたがPerlにはないようです)。

このようなケースはDecpackを使えば大幅に圧縮できます。Decpackは次の方法で固定小数点数を整数に変換してエンコードします。

1. 有効桁数と同じ回数だけ10を掛けた後四捨五入して整数に変換
2. 整数が符号付きの場合はビット幅の半分をオフセットとして加え符号なしに変換

まず規則1に従い10を掛けて整数化し、次にデータに必要なビット幅を見積ります。

データの最大値は14.8ですからこれに10を掛けた148までを考えればビット幅8の中に保存できます。しかし実際の気温データは25.6℃以上や氷点下になることもあります。より現実的な選択は次の2つのどちらかです。

1. ビット幅10: -51.2 .. +51.1 (日本国内用の設定)
2. ビット幅11: -102.4 .. +102.3 (世界歴代最低、最高まで考慮した設定)

> 気象庁によれば日本国内の気温の最低記録は-41.0℃(北海道旭川)、最高記録は+41.0℃(高知県江川崎)です(絶対値が同じなのは偶然の一致です)。世界記録については諸説ありますが正負どちらも100を超える観測値はまだないようです。

> <http://www.data.jma.go.jp/obd/stats/etrn/view/rankall.php?prec_no=&block_no=&year=&month=&day=&view=>

コード例は次の通りです(日本以外でも使えるように2の仕様を採用しています)。圧縮後のサイズは33バイトで、pack/unpackに比べて際立った効果があります。

    require 'decpack'

    temp = [
       7.8,  7.1,  8.2,  6.4,  5.9,  5.5,  5.9,  8.4,  8.2, 10.8, 12.3, 13.0,
      14.6, 14.8, 14.8, 13.6, 12.1, 10.5, 12.5, 12.4, 12.0,  9.8, 11.4, 10.7
    ]

    pack = Decpack.pack type: :binary
    temp.each {|x| pack.r 11, 1, x }
    packed = pack.output
    p packed.size       # => 33

    unpack = Decpack.unpack packed
    unpacked = 24.times.map { unpack.r 11, 1 }
    p unpacked          # 丸め誤差のため次のように出力します
    # => [7.800000000000001, 7.1000000000000005, 8.200000000000001,
    #     6.4, 5.9, ... 10.700000000000001]

    # printfを使い丸め誤差を表示しないようにする
    puts '[' + unpacked.map {|x| sprintf '%.1f', x}.join(', ') + ']'
    # => [7.8, 7.1, 8.2, ... 10.7]

ここで`pack.r 11, 1, x`と`unpack.r 11, 1`の`r`はエンコーダ及びデコーダオブジェクトで符号付き小数点数を変換するメソッド名、第一引数の`11`はビット幅、第二引数の`1`は小数桁数です。これも後で詳しく説明します。

以上がDecpackの基本的な処理です。原理は単純ですが小数桁数があらかじめ決まっている数値に対してビット幅を絞り込むことにより効率的な圧縮保存ができるメリットがあります。

> Decpackにgzipなどの圧縮フォーマットを組み合わせるのは効果的な応用です。もう一つの有力候補はCSVとgzipの組み合わせで、これもほぼ同じ効率で圧縮できます。両者の比較について本ドキュメントの最後で詳しく考察します。

##  処理の流れ

ここからモジュールの詳細説明に入りますが、最初に圧縮保存(エンコード)とデータ読み出し(デコード)の操作手順を簡単にまとめておきます。モジュールの性格上、圧縮保存とその読み出しは通常別々の処理になります。

### 圧縮保存の場合

* `Decpack.pack`で圧縮エンコーダオブジェクトを作成
* エンコーダオブジェクトにデータ形式を指定してデータを出力
* 全てのデータ出力が終わったらoutputメソッドで結果を文字列として取得
* 必要に応じて結果の文字列をファイル保存またはXHRで出力

### 圧縮データ読み出しの場合

* 圧縮された文字列データを取得(ファイル読み込み、XHRリクエスト等)
* `Decpack.unpack`で圧縮デコーダオブジェクトを作成(引数に圧縮文字列を渡す)
* デコーダオブジェクトからデータ形式を指定してデータを読み出す

## データ型

Decpackは次のデータを入出力の対象とします。これら4種類(及びnil)のデータを効率的に圧縮保存することに特化しており、その他のデータ型(特に文字列)は対象外です。

* 最大桁数またはビット幅を持つ符号なし整数
* 最大桁数またはビット幅を持つ符号付き整数
* 最大桁数またはビット幅を持ち、小数点の有効桁数が固定の数値
* 最大桁数またはビット幅を持ち、小数点の有効桁数が固定の数値
* nil (JavaScriptの場合はnull)

上記4種類以外の型のデータは外部に別手段で確保して参照する解決手段があります。データに名前を付ける場合は外部データに整数IDと名前を格納し、Decpackデータの一部にIDを保存しておけば両者を関連付けることができます。

> 配列などデータ構造の機能もありませんが、自分で規則を決めて配列その他のデータ構造に対して入出力することはそんなに難しくありません。

## フォーマット

Decpackはpack/unpackと同じように文字列(String)に対して入出力を行いますが、フォーマット(エンコーディング)は2種類あります。

### バイナリフォーマット

(PerlやRubyの)pack/unpackと同じようにバイナリエンコーディングの文字列を使い、1文字(バイト)あたり8bit全てを使います。RubyではStringオブジェクトでエンコーディングはASCII-8BIT(BINARY)に設定されます。

バイナリフォーマットを用いる場合は`Decpack.pack`でエンコーダオブジェクトを生成する際のオプション引数に`type: :binary`を指定します。

### テキストフォーマット

US-ASCII(7bit)エンコーディング文字列を使い、その中から64文字だけを使ってコード化します。1文字当たりのデータ量は6bitで全データ量は8/6倍に増大しますが、インターネットでバイナリデータを扱う際の問題のほとんどを回避することができます。

使用する文字は次の64文字です。インターネットで用いられるマークアップ文字やエスケープ文字(`<,>,&,?,#,%`など)を避け、通信で文字化け等の問題を生じないよう配慮しています。

    '0', '1', ... , '9',
    'A', 'B', ... , 'Z',
    'a', 'b', ... , 'z',
    '-', '_'

> Base64によく似ていますが、Base64の`/`と`+`はURLの特殊記号に含まれるためより安全な`-`と`_`を使っています(正規表現では`-`は文字クラス中で`[A-Z]`のように特殊な意味を持ちますが、`[`や`]`を使っていないため英数字と同じ扱いになります)。

これは特にJavaScriptを用いてXHR(AJAX)でデータ読み込みを行う場合を考えた仕様です。XHRでバイナリデータを読み込む事は可能ですがまだ一般的ではなく、Webフレームワークも多くはまだ未対応という状況です。

> 例えばjQuery.ajaxは(2014年現在)まだバイナリデータに対応していません。

テキストフォーマットは`Decpack.pack`でエンコーダオブジェクトを生成する場合のデフォルトに設定されています(オプション不要)。設定する場合は`type: :text`を指定します。

テキストフォーマットで圧縮したデータをブラウザからXHRで読み込み、JavaScriptデコーダで復元すれば通信時間を短縮できるメリットがあります。

## エンコーダオブジェクト

### エンコーダの生成

エンコーダオブジェクトは`Decpack.pack`で生成します。

* Decpack.pack(option = {}) - エンコーダオブジェクトを生成

次のオプションハッシュを受け付けます。

* :type - データフォーマットの指定
    - :text (デフォルト) - テキストフォーマット
    - :binary - バイナリフォーマット

* :nil - nilの扱いの有無
    - falseまたはnil (デフォルト) - nilを扱わない(nilの入力はTypeError)
    - true (任意の真値) - nilを扱う

* :limit - 範囲外の入力に対する処理
    - falseまたはnil (デフォルト) - 例外(RangeError)を発生
    - true (任意の真値) - 範囲内の(最小または)最大に値を切り詰めて保存

* :eof - データ終了判定機能の有無
    - falseまたはnil (デフォルト) - 判定機能を用いない
    - true (任意の真値) - デコーダ側でeofのデータ終了判定機能を用いる

nilオプションを有効にした場合は数値以外にnilを入出力できるようになり、その代わり指定ビット幅で表現できる数の範囲が1減少します。

limitオプションを有効にすると指定ビット幅の範囲を超える入力値を上下限値に制限して保存します。指定しない場合は範囲外の値はエラーとなりRangeError例外を発生します。

eofオプションを使用するとエンコード結果の先頭に総ビット数が書き込まれ、デコード時にデータ終端に達したかどうかチェックできるようになります。

> eofオプション指定時はデータ容量に次の制限があります。
> 
> * バイナリ - 1GByte (32bit空間)
> * テキスト - 256MByte (30bit空間)

文例を示します。

    # デフォルト(テキストフォーマット、nilなし、リミットなし、EOFなし)
    pack = Decpack.pack

    # バイナリフォーマット、nilを使用
    pack = Decpack.pack type: :binary, nil: true

    # テキストフォーマット、nilを使用、デコード側でEOFを判定
    pack = Decpack.pack nil: true, eof: true

### エンコード処理

エンコード処理は次の4つのメソッドで行います。これらは全て対応する型の数値データを圧縮エンコードして内部表現の文字列データに追加します。

* .B(bit\_width, data) - 符号なし整数をエンコード
    - bit\_width - ビット幅
    - data - 符号なし整数、またはnil(nilオプション指定時のみ)

* .b(bit\_width, data) - 符号付き整数をエンコード
    - bit\_width - ビット幅
    - data - 符号付き整数、またはnil(nilオプション指定時のみ)

* .R(bit\_width, fraction\_width, data) - 符号なし固定小数点数をエンコード
    - bit\_width - ビット幅
    - fraction\_width - 10進表現の小数部桁数
    - data - 符号なし固定小数点数、またはnil(nilオプション指定時のみ)

* .r(bit\_width, fraction\_width, data) - 符号付き固定小数点数をエンコード
    - bit\_width - ビット幅
    - fraction\_width - 10進表現の小数部桁数
    - data - 符号付き固定小数点数、またはnil(nilオプション指定時のみ)

データの表現範囲はビット幅(bit\_width)で決まりますが、nilオプションを有効にした場合は内部表現の0をnilに割り当てるため値の範囲が1小さくなります。正確な範囲の一覧はこの後の「データの表現範囲」を参照して下さい。

より簡便に10進桁数でも指定できるよう次のメソッドも用意されています。

* .D(digits, data) - 符号なし整数をエンコード
    - digits - 10進桁数
    - data - データ(符号なし整数、nilオプション指定時はnilも可)

* .d(digits, data) - 符号付き整数をエンコード
    - digits - 10進桁数
    - data - データ(符号なし整数、nilオプション指定時はnilも可)

* .F(digits, fraction\_width, data) - 符号なし固定小数点数をエンコード
    - digits - 10進桁数(整数部+小数部)
    - fraction\_width - 小数部桁数
    - data - データ(符号なし固定小数点数、nilオプション指定時はnilも可)

* .f(digits, fraction\_width, data) - 符号付き固定小数点数をエンコード
    - digits - 10進桁数(整数部+小数部)
    - fraction\_width - 小数部桁数
    - data - データ(符号なし固定小数点数、nilオプション指定時はnilも可)

これらは全て10進桁数から必要な2進ビット幅を求め、対応する2進バージョンのメソッドを呼び出しています。符号付きの場合は負の数の分だけ自動的にビット幅が1加算されます。

もうひとつ特殊用途用のメソッドがあります。

* .raw(bit\_width, data) - 符号なし整数を内部表現に直接エンコード
    - bit\_width - ビット幅
    - data - データ(符号なし整数、nilオプション指定時はnilも可)

これはeofオプションなしの場合のBメソッドと同じ動作で、eofオプションありの場合もnilを入力するとエラーになり、その代わり数の表現範囲が1増えます(元は内部実装用)。主にビットフィールドフラグの保存に用いられます。

この他に配列データをまとめてエンコードする機能があります。これは後半の「配列のエンコード・デコード」で説明します。

### エンコード出力

エンコーダへのデータ入力が終わったらoutputメソッドで結果を取得します。引数はありません。

* .output - エンコード結果の文字列を取得
    - テキストフォーマット - 戻り値はUS-ASCIIエンコーディング文字列
    - バイナリフォーマット - 戻り値はASCII-8BITエンコーディング文字列

> その後の処理は用途により様々ですが、例えばエンコードした文字列をファイルに保存したり、あるいはサーバサイド処理の場合はリモートクライアント(アクセスしているブラウザ)に返信します。

### その他のメソッド

オブジェクトの設定状態は次のメソッドで取得できます。

* .text? - テキストモードの場合に真値を返す
* .binary? - バイナリモードの場合に真値を返す
* .use\_nil? - 生成時にnilオブションを指定した場合に真値を返す
* .limit? - 生成時にlimitオブションを指定した場合に真値を返す
* .support\_eof? - 生成時にeofオプションを指定した場合に真値を返す

## デコーダオブジェクト

### デコーダの生成

圧縮保存したデータを復元するにはまず`Decpack.unpack`でデコーダオブジェクトを生成します。

* Decpack.unpack(input, option = {}) - デコーダオブジェクトを生成
    - input - Decpack.packでエンコードされた文字列
    - option - オプションハッシュ

次のオプションハッシュを受け付けます。

* :nil - nilの扱いの有無
    - falseまたはnil (デフォルト) - nilを扱わない
    - true (任意の真値) - nilを扱う

* :eof - データ終了判定を行うかどうかの有無
    - falseまたはnil (デフォルト) - 判定を行わない
    - true (任意の真値) - eofメソッドでデータ終了判定をサポートする

* :type - データフォーマット(自動判定機能があるためデフォルト値なし)
    - :text - テキストフォーマットに強制
    - :binary - バイナリフォーマットに強制

nilオプションとeofオプションは必ずエンコーディング時と同じ設定にして下さい。データ保存効率を最大にするため、データ側には(eofオプション指定時のビットサイズを除き)作成時情報は含まれていません。

> データの内部表現はnilオプション有効時と無効時で異なるため、設定が異なるとデコード結果が別の値になります。eofオプションも同様に有り無しでデータ長が変わるため正しくデコードできなくなります。

typeオプションは通常は設定不要です。指定しない場合はinputの文字エンコーディングを取得して次の順番でフォーマットを決定します。

* ASCII-8BIT(BINARY)の場合はバイナリフォーマット
* その他のASCII互換エンコーディングの場合はテキストフォーマット
* ASCII非互換の場合はエラー(ArgumentError)

指定した場合はオプション設定を優先します。これはinputの型チェック用で、文字エンコーディングチェックを行い次の条件にマッチしない場合はエラー(ArgumentError)を発生します。

* :binaryを指定した場合はASCII-8BIT(BINARY)のみ有効
* :textを指定した場合は任意のASCII互換エンコーディングが有効

### デコード処理

デコード処理は次の4つのメソッドで行います。これらは全て対応する型の数値データを文字列からシーケンシャルに読み出してその値を返します。

* .B(bit\_width) - 符号なし整数をデコード
    - bit\_width - ビット幅
    - 戻り値 - データ(符号なし整数、またはnilオプション有効時はnil)

* .b(bit\_width) - 符号付き整数をデコード
    - bit\_width - ビット幅
    - 戻り値 - データ(符号付き整数、またはnilオプション有効時はnil)

* .R(bit\_width, fraction\_width) - 符号なし固定小数点数をデコード
    - bit\_width - ビット幅
    - fraction\_width - 10進表現の小数部桁数
    - 戻り値 - データ(符号なし固定小数点数、またはnilオプション有効時はnil)

* .r(bit\_width, fraction\_width) - 符号付き固定小数点数をデコード
    - bit\_width - ビット幅
    - fraction\_width - 10進表現の小数部桁数
    - 戻り値 - データ(符号付き固定小数点数、またはnilオプション有効時はnil)

デコーダにもこれらの10進バージョンがあります。

* .D(digits) - 符号なし整数をデコード
    - digits - 10進桁数
    - 戻り値 - 符号なし整数、またはnil(nilオプション有効時のみ)

* .d(digits) - 符号付き整数をデコード
    - digits - 10進桁数
    - 戻り値 - 符号付き整数、またはnil(nilオプション有効時のみ)

* .F(digits, fraction\_width) - 符号なし固定小数点数をデコード
    - digits - 10進桁数(整数部+小数部)
    - fraction\_width - 10進表現の小数部桁数
    - 戻り値 - 符号なし固定小数点数、またはnil(nilオプション有効時のみ)

* .f(digits, fraction\_width) - 符号付き固定小数点数をデコード
    - digits - 10進桁数(整数部+小数部)
    - fraction\_width - 10進表現の小数部桁数
    - 戻り値 - 符号付き固定小数点数、またはnil(nilオプション有効時のみ)

rawメソッドもエンコーダの場合と同じです。

* .raw(bit\_width) - 符号なし整数の内部表現に直接デコード
    - bit\_width - ビット幅
    - 戻り値 - 符号なし整数(nilオプション有効時もnilを返さない)

これらはエンコード時と同じ設定と順序でコールした場合だけ正しくデータを復元できます。(eofオプション有効時のデータ長を除き)データのチェック機能はありません。これはデータの冗長性を排除して全情報を数値に割り当てているためです。

### その他のメソッド

eofオプションを有効にしている場合は次のデータ終端判定メソッドを利用できます。

* .eof - データ終了判定
    - false - データ終端に達していない
    - true - データ終端に達した

またeofオプション有効時はデータ終端を越えてデコード処理を行うとEOFError例外を発生します。

オブジェクトの設定状態は次のメソッドで取得できます(エンコーダオブジェクトと同様)。

* .text? - テキストモードの場合に真値を返す
* .binary? - バイナリモードの場合に真値を返す
* .use\_nil? - 生成時にnilオブションを指定した場合に真値を返す
* .support\_eof? - 生成時にeofオプションを指定した場合に真値を返す

## 配列のエンコード・デコード

pack/unpackと同じように配列データをまとめてエンコード・デコード処理できます。

エンコーダ側では次のメソッドで配列をまとめてエンコードできます。

* .array(format, data\_array)
    - format - フォーマット文字列(または後述のフォーマット内部表現配列)
    - data\_array - エンコードするデータの配列

デコーダにも同名メソッドがあり、デコード結果を配列として返します。

* .array(format)
    - format - フォーマット文字列(または後述のフォーマット内部表現配列)
    - 戻り値 - デコード結果の配列

フォーマットは次のような文字列で指定します。

    "B3D4f5.2F5.1"

ひとつのデータに対する書式設定はメソッド名と同じアルファベットから始まり、その後にデータ長(と小数桁数)をprintfに似た書式で記述します。

    B{2進ビット長}
    b{2進ビット長}
    R{2進ビット長}.{10進小数桁数}
    r{2進ビット長}.{10進小数桁数}
    D{10進桁数}
    d{10進桁数}
    F{10進桁数}.{10進小数桁数}
    f{10進桁数}.{10進小数桁数}

間に空白を置いてもかまいません(単に無視して処理)。

    "B3 D4 f5.2 F5.1"

ただしアルファベットと数の間に空白を入れるとエラーになります。

    "B3"      => OK
    "B 3"     => NG (ArgumentError)

> packではアルファベットの後に個数を表す数値または`*`を指定できますが、Decpackはこの機能をサポートしません(アルファベットに続く数値はデータ長を表します)。

エンコーダ・デコーダ双方のarrayメソッドではまずフォーマット文字列を解析して内部表現の配列に変換してから処理します。そこで同じフォーマット設定を複数回使用する場合は次の関数であらかじめ内部表現に変換しておけば効率的に処理できます。

* Decpack.parse\_format(format\_string)
    - format\_string - フォーマット文字列
    - 戻り値 - フォーマット内部表現配列

## データの表現範囲

エンコード・デコード処理メソッドで処理できる数の上限、下限は次の通りです。nilオプション有効時は絶対値の最大が1減少します。またエンコーダのlimitオプションを有効にするとこの範囲内に値が制限されます。

     method    nil              minimum                       maximum
    --------  -----  ------------------------------  -------------------------
      B(w)    false                0                        2 ** w - 1
      B(w)    true                 0                        2 ** w - 2
      b(w)    false         -(2 ** (w - 1))              2 ** (w - 1) - 1
      b(w)    true        -(2 ** (w - 1) - 1)            2 ** (w - 1) - 1
     R(w, f)  false                0                  (2 ** w - 1) * 0.1 ** f
     R(w, f)  true                 0                  (2 ** w - 2) * 0.1 ** f
     r(w, f)  false    -(2 ** (w - 1)) * 0.1 ** f    (2 ** (w - 1)) * 0.1 ** f
     r(w, f)  true   -(2 ** (w - 1) - 1) * 0.1 ** f  (2 ** (w - 1)) * 0.1 ** f

## JavaScriptデコーダ

WebアプリケーションでXHRを用いたデータ通信に対応するためJavaScriptデコーダを用意しています。CoffeeScriptで記述していますが、生成済みJavaScriptファイルも添付しています(実行に必要なのはJavaScriptファイルだけです)。

HTMLから利用する場合はjavascript/Decpack.jsをブラウザから参照できる場所にコピーして`<script>`で読み込んで下さい。またnode.jsのモジュールとしても機能します。ロード手順は次の「デコーダオブジェクトの生成」で説明します。

> JavaScript版にはエンコーダはありません。またテストコードもありません。コードはまだ全環境では確認しておらず、ブラウザ上でテキストフォーマットのデータを受信してデコードできるだけ確認しています。

### デコーダオブジェクトの生成

ブラウザ上では次のコンストラクタ関数でデコーダを生成します。オプションはRuby版と同じです。

* Decpack.unpack(input, option) - デコーダオブジェクトを生成
    - input - データ(型によりテキスト/バイナリを自動判定)
    - option - オプション(オブジェクト)
        - .nil - nullを扱う場合真を指定
        - .eof - データ終端判定を行う場合真を指定

> 先頭にnewは不要です(付けても結果は同じです)。

node.jsの場合はrequireでモジュールをロードします。node.jsの対話モードを使った実例を示します。

    $ node
    > decpack = require('./javascript/Decpack')
    { unpack: [Function],
      parseFormat: [Function] }
    > unpack = decpack.unpack('dummy data', {nil: true})
    { dec: 
       { data: 'dummy data',
         byte_off: 0,
         bit_off: 0 } }

JavaScript版ではコンストラクタの第一引数の型でテキスト/バイナリを判断します。

* テキスト - 引数は文字列(String)
* バイナリ(ブラウザの場合) - 引数はUint8Array
* バイナリ(node.jsの場合) - 引数はBuffer

### メソッド

仕様はRuby版デコーダと同じですが、最後の`Decpack.parseFormat`だけメソッド名がRuby流の`parse_foprmat`ではなくJavaScript流の`parseFormat`に変わっています。

* .B(bitWidth) - 符号なし整数をデコード
    - bitWidth - ビット幅
    - 戻り値 - 符号なし整数、またはnull(nilオプション指定時)

* .b(bitWidth) - 符号付き整数をデコード
    - bitWidth - ビット幅
    - 戻り値 - 符号付き整数、またはnull(nilオプション指定時)

* .R(bitWidth, fractionWidth) - 符号なし固定小数点数をデコード
    - bitWidth - ビット幅
    - fractionWidth - 10進表現の小数部桁数
    - 戻り値 - 符号なし固定小数点数、またはnull(nilオプション指定時)

* .r(bitWidth, fractionWidth) - 符号付き固定小数点数をデコード
    - bitWidth - ビット幅
    - fractionWidth - 10進表現の小数部桁数
    - 戻り値 - 符号付き付き固定小数点数、またはnull(nilオプション指定時)

* .D(decimalWidth) - 符号なし整数をデコード
    - decimalWidth - 10進桁数
    - 戻り値 - 符号なし整数、またはnull(nilオプション指定時)

* .d(decimalWidth) - 符号付き整数をデコード
    - decimalWidth - 10進桁数
    - 戻り値 - 符号付き整数、またはnull(nilオプション指定時)

* .F(decimalWidth, fractionWidth) - 符号なし固定小数点数をデコード
    - decimalWidth - 10進桁数
    - fractionWidth - 10進表現の小数部桁数
    - 戻り値 - 符号なし固定小数点数、またはnull(nilオプション指定時)

* .f(decimalWidth, fractionWidth) - 符号付き固定小数点数をデコード
    - decimalWidth - 10進桁数
    - fractionWidth - 10進表現の小数部桁数
    - 戻り値 - 符号付き付き固定小数点数、またはnull(nilオプション指定時)

* .raw(bitWidth) - 符号なし整数(内部表現)に直接デコード
    - bitWidth - ビット幅
    - 戻り値 - 符号なし整数

* .eof() - データ終了判定(nilオプション指定時のみ有効)
    - false - データ終端に達していない
    - true - データ終端に達した

* .array(format) - 配列にデコード
    - format - フォーマット文字列または内部表現(Decpack.parseFormatの出力)

* Decpack.parseFormat(formatString) - フォーマット文字列を処理
    - format - フォーマット文字列
    - 戻り値 - 内部表現(.array(format)の引数に用いる)

## Decpackと可逆圧縮アルゴリズム

Decpackは小数桁数が決まっている数値データを圧縮するモジュールですが、データの使っていない部分のビットを詰めること以外には何も行いません。そのためgzipやbzip2などの可逆圧縮アルゴリズムとの併用が更に効果的です。

gzipなどで圧縮する場合の元フォーマットとしてもうひとつの有力候補は実はCSVです。CSVで表された数値データはそのままではサイズは大きくなりますが、ごく一部のASCIIキャラクタしか使っていませんから効率的に圧縮できます。

> DecpackとCSVはどちらも数値を表現するのに余計な(有効桁数より下の)情報を含んでいないことが特徴です。これに対しpackで生成したデータは常に有効桁数を全て保存するため必要以上の精度情報を含んでいます。

gzip圧縮によりCSVとDecpackのどちらが小さくなるかはデータの性質により結果が異なります。大まかな性質としては同じデータの重複が少なければDecpack、多ければCSVがコンパクトになる傾向があります。

以下では同じデータの重複がほとんどない乱数データと、実際の測定値を用いた場合の両方でDecpackとCSVをgzip圧縮して結果を比較します。

#### 乱数データの場合

確認コードの`example/test_random_data.rb`は乱数を生成してCSV、pack、Decpackテキスト、Decpackバイナリの4種類で保存し、さらにgzip圧縮してファイルサイズを比較します。条件は次の通りです。

* データ数は100000
* 乱数を使い10進で1-6桁のランダムな数値を生成
* 乱数を使い整数と小数点数を1:1の比率で生成
* 小数点数の場合は小数桁数もランダムに生成
* CSVとDecpackは生成時と同じ10進桁数で保存
* packは整数に`l`、小数点数に`f`を使用(どちらも4byteのため結果は必ず400000)

乱数データは重複がないためgzipはデータ自身には効かず各フォーマット固有の冗長性に対して効果を持ちます。結果は次の通りで、拡張子の`csv`はCSV、`pack`はpack、`dp6`はDecpackテキストフォーマット、`dp8`はDecpackバイナリフォーマットです。

    642512  random_data.csv
    308138  random_data.csv.gz
    400000  random_data.pack
    328320  random_data.pack.gz
    273232  random_data.dp6
    206587  random_data.dp6.gz
    204924  random_data.dp8
    204993  random_data.dp8.gz

> この他にgzipより圧縮率の高いbzip2についても測定していますがgzipとほぼ同傾向の結果になるため省略します(全結果はソースプログラム末尾の`__END__`以降にあります)。

CSVにはgzip圧縮がよく効き半分以下に小さくなります。packを使えば元のファイルサイズは小さくなりますが圧縮があまり効かず、圧縮後はCSVよりやや大きくなります。

> 浮動小数点数の内部表現は2進で、10進小数点数は(0.5や0.25など2のべきで表現できる場合を除き)近似値でしか表現できません。仮数部の大部分が埋まっている状態なのでpackの結果を圧縮してもあまり効果はありません。

上記の結果で最も優秀なのはDecpackのバイナリフォーマットで、冗長性がほとんどないためgzip圧縮が効かずむしろ元より大きくなります。テキストの場合はちょうどフォーマットの差の分だけ圧縮が効き、バイナリとほぼ同サイズになります。

圧縮後のサイズを比較するとDecpackが最もよく、packやCSVの約3/2まで小さくできます。しかしこれはあくまで乱数データの場合で、実際のデータはある程度の重複を含むためこれとは異なる結果になります。

#### 実測データの例

ある程度の重複が存在するデータでは重複の発生頻度で結果が異なります。確認コードの`example/test_real_data.rb`は東京の長期間気象トレンドデータを乱数の場合と同条件で処理します。

元データは一日ごとの気象データ`example/tokyo_daily_weather.csv`です。データフォーマットは次の通りで、一日分のデータは時刻(epoch time)、最低気温(℃)、最大気温(℃)、降水量(mm)の4つです。

    (epoch-time),(minimum-temperature),(maximum-temperature),(precipitation)

データの一部を紹介します(最後の部分)。降雨のない日は降水量が全て`0.0`になりますから多くのデータ重複があります。

    ...
    1382540400,15.1,17.5,2.0
    1382626800,15.7,20.4,14.0
    1382713200,13.5,17.9,36.0
    1382799600,12.0,21.1,0.0
    1382886000,12.1,20.3,0.0
    1382972400,13.2,16.0,5.0
    1383058800,14.9,22.1,0.0
    1383145200,13.8,21.5,0.0

このデータを圧縮処理した結果は次の通りです。この場合も圧縮後で比較するとDecpackが最もよい結果になりますが、乱数データの場合ほど大きな効果にはなりません。

    568375  tokyo_daily_weather.csv
    179617  tokyo_daily_weather.csv.gz
    378432  tokyo_daily_weather.pack
    188392  tokyo_daily_weather.pack.gz
    252292  tokyo_daily_weather.dp6
    173440  tokyo_daily_weather.dp6.gz
    189220  tokyo_daily_weather.dp8
    157542  tokyo_daily_weather.dp8.gz


さらに重複が多いデータになると形勢が逆転します。まず元データ`example/tokyo_hourly_weather.csv`のフォーマットは次の通りです。

    (epoch-time),(temperature),(precipitation)

データの一部(最後の部分)を示します。今度は1時間ごとのデータのため降水量はほとんどが`0.0`になり、大量の重複があります。

    ...
    1383015600,14.4,0.0
    1383019200,14.1,1.5
    1383022800,14.5,2.0
    1383026400,14.8,0.5
    1383030000,15.5,0.0
    1383033600,15.3,0.5
    1383037200,15.3,0.0
    ...中略(この間降水量は全て0.0)...
    1383206400,20.3,0.0
    1383210000,20.0,0.0
    1383213600,19.4,0.0
    1383217200,18.8,0.0
    1383220800,16.9,0.0
    1383224400,16.8,0.0
    1383228000,17.5,0.0
    1383231600,17.2,0.0

このデータを処理すると次の結果になります(`examples/test_real_data_2.rb`)。gzip圧縮後の順位は逆転してCSVが最もよく、Decpackが最も悪くなります。

    4021507  tokyo_hourly_weather.csv
     928861  tokyo_hourly_weather.csv.gz
    2506908  tokyo_hourly_weather.pack
     989541  tokyo_hourly_weather.pack.gz
    1810550  tokyo_hourly_weather.dp6
    1061045  tokyo_hourly_weather.dp6.gz
    1357913  tokyo_hourly_weather.dp8
    1001055  tokyo_hourly_weather.dp8.gz

## ライセンス

MIT
